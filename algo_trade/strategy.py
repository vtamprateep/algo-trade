from dataclasses import dataclass, field
from abc import ABCMeta, abstractmethod

import queue
import numpy as np
import pandas as pd


class Strategy(object):
    '''
    Abstract base class providing interface for all subsequent strategy handling objects.

    Goal of Strategy object is to generate Signal objects for particular tickers/symbols based on inputs of data/bars generated by a DataHandler object

    This is designed to work with both historic and live data as Strategy is agnostic to where the data come from, since it obtains the bar tuples from a queue object
    '''
    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        raise NotImplementedError('Should implement calculate_signals()')

class ExponentialMovingAverage(Strategy):
    def __init__(self, data, ewa_short=10, ewa_long=26, buffer=0):
        self.population = ['SPY']
        self.params={
            'ewa_short': ewa_short,
            'ewa_long': ewa_long,
        }
        self.data = data

    def calculate_signals(self):
        dataclose = self.data['SPY'].close
        ewa_short_value = dataclose.ewm(span=self.params['ewa_short']).mean().iloc[-1]
        ewa_long_value = dataclose.ewm(span=self.params['ewa_long']).mean().iloc[-1]

        ewa_avg = (ewa_short_value + ewa_long_value) / 2
        ewa_diff = ewa_short_value - ewa_long_value

        ewa_signal = ewa_diff / ewa_avg

        if ewa_signal > 0 and abs(ewa_signal) > self.params['buffer']:
            return True
        elif ewa_signal < 0 and abs(ewa_signal) > self.params['buffer']:
            return False
        else:
            return None

class MarketPortfolio(Strategy):
    def __init__(self):
        self.population = ['SPY']

    def calculate_signals(self):
        return pd.DataFrame(
            data={
                'ticker': self.population,
                'weight': [1]
            }
        )